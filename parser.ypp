 %{
//	#define YYERROR_VERBOSE 1 
	#include <iostream>
	#include <stdlib.h>
	#include "hw3_output.hpp"
	#include "types.hpp"
	#include "symbolsTable.hpp"
	using namespace std;
	
	extern int yylex();
	extern int yylineno;
	//int yyerror(const char * message);

    symbolsTable vars_table;         // The symbols table for variables.
    FuncsTable funcs_table;          // The table for all functions declared.
    bool new_scope = false;

	
%}

%token    VOID 
%token    INT 
%token    BYTE 
%token    B 
%token    BOOL 

%token    TRUE 
%token    FALSE 
%token    RETURN 
%token    WHILE 
%token    BREAK 
%token    CONTINUE  
%token    SC 
%token    COMMA 
%token    ASSIGN
%token    ID 
%token    NUM 
%token    STRING
%token    SET;

%left OR;                // changed
%left AND;
%left RELOPN;
%left RELOPR;            // is RELOP == | != 
%nonassoc     RELOPL;            // is RELOP <= | >= | > | < should be left 
%left     ADDSUB;               // add is +/-       /// splitted BINOP
%left     MULDIV;               // MUL is * or /
%right    NOT;

%left     LPAREN;
%left    RPAREN;
%nonassoc     COMMA;
%left    LBRACE;
%left    RBRACE;
%left    LBRACKET;
%left  RBRACKET;          /// not sure about LBRACKET AND LBRACKET  should be treated as LBRACE/RBARACE or LPAREN/RPAREN

%left    DOTS;
%nonassoc IF;
%right    ELSE;
%%

Program:  Funcs
          {
			  funcs_table.printTable();
		  }
		  
Funcs :  
		  {
		      
		  } 	

		  | FuncDecl Funcs 
		  {
		      
		  }
		  
FuncDecl: RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE 
		  {
			
		  }

RetType:  Type
          {
			  $$.type = $1.type;
		  }
		  | VOID
		  {
			  $$.type = "VOID";
		  }

Formals: 
		  {
		      
		  }
		  | FormalsList
		  {
		      
		  }		

FormalsList:FormalDecl 
		  {
		      
		  }
		  | FormalDecl COMMA FormalsList
		  {
		      
		  }

FormalDecl: Type ID
		  {
		      vars_table.Insert($2.name, $1.type,false,true);
		  }
		  
Statements: Statement
		  {
		      
		  }
		  | Statements Statement	
		  {
		      
		  }
Statement: LBRACE Statements RBRACE	
		  {
		      
		  }
		  | Type ID SC	
		  {
		    
		  }
		  | Type ID ASSIGN Exp SC	
		  {
		      
		  }
		  | ID ASSIGN Exp SC	
		  {
		      
		  }	
		  | Call SC
		  {
		      
		  }
		  | RETURN SC	
		  {
		      
		  }
		  | RETURN Exp SC
		  {
		      
		  }
		  | IF LPAREN Exp RPAREN Statement 	
		  {
		      
		  }
		  | IF LPAREN Exp RPAREN Statement ELSE Statement
		  {
		      
		  }
		  | WHILE LPAREN Exp RPAREN Statement
		  {
		      
		  }
		  | BREAK SC
		  {
		      
		  }	
		  | CONTINUE SC
		  {
		      
		  }
		  
Call:      ID LPAREN Explist RPAREN 
          {
			  $$=new Call(funcs_table.checkArgsValid(($1->name,dynamic_cast<ExpList*>$3->types)); //not sure about the $1->name
		  }
          | ID LPAREN RPAREN 
		  {
			 $$=new Call(funcs_table.checkArgsValid(($1->name,{}));
		  }

Explist:    Exp 
          {
	         $$= new ExpList (dynamic_cast<Exp*> ($1));
		  }
          | Exp COMMA Explist 
		  {
			$$= new ExpList (dynamic_cast<Exp*>($1),dynamic_cast<ExpList*>($3));  
		  }

Type :      INT 
          {
			$$.type = $1.type;
		  }
          |  BYTE 
		  {
			$$.type = $1.type;
		  }
          | BOOL 
		  {
			$$.type = $1.type;
		  }
          | SET LBRACKET NUM DOTS NUM RBRACKET 
		  {
			 //todo
		  }

Exp:        LPAREN Exp RPAREN 
          {
			 $$=$1;
		  }
          | ID //todo // I think this needs the function that looks up a variable
		  {
			 
		  }
          | Call 
		  {
			  $$=$1; 
		  }
          | NUM 
		  {
			  $$.type = "INT";
              
		  }
          | NUM B 
		  {
			 $$.type = "BYTE";
             if($1.name > 255 ){  //the stored value is name right?   //byte can't be above 255
                output::errorByteTooLarge(yylineno, $1.name);
                exit(0);
             }
		  }
          | STRING 
		  {
			  $$.type = "STRING";
		  }
          | TRUE 
		  {
			  $$.type = "BOOL";
		  }
          | FALSE 
		  {
			  $$.type = "BOOL";
		  }
          | NOT Exp 
		  {
            if($1.type != "BOOL"){
                output::errorMismatch(yylineno);
                exit(0);
            }else{
                $$.type = "BOOL";
            
            }
			  
		  }
          | Exp AND Exp 
		  {
			if(($1.type != "BOOL") || ($3.type != "BOOL")){
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$.type = "BOOL";
		  }
          | Exp OR Exp 
		  {
			 if(($1.type != "BOOL") || ($3.type != "BOOL")){
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$.type ="BOOL";
		  }
          | Exp ADDSUB Exp 
		  {
			 if((($1.type != "INT") &&($1.type != "BYTE"))  || (($3.type != "INT") &&($3.type != "BYTE")) ){
                output::errorMismatch(yylineno);
                exit(0);
            }
            if(($1.type == "INT") ||($2.type == "INT")){
                
                $$.type = "INT";
            }else{
                $$.type = "BYTE";
            
            }
		  }
          | Exp MULDIV Exp 
		  {
			  if((($1.type != "INT") &&($1.type != "BYTE"))  || (($3.type != "INT") &&($3.type != "BYTE"))){
                output::errorMismatch(yylineno);
                exit(0);
            }
            if(($1.type == "INT") ||($2.type == "INT")){
                
                $$.type ="INT";
            }else{
                $$.type ="BYTE";
            
            }
		  }
		  | Exp RELOPN Exp  //todo
		  {
			  
		  }
          | LPAREN Type RPAREN Exp 
		  {
            if(($2.type!="INT") || $3.type !="SET"){
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$.type = "INT";
			 
		  }
		  | Exp RELOPL Exp
		  {
			if((($1.type != "INT") &&($1.type != "BYTE"))  || (($3.type != "INT") &&($3.type != "BYTE"))  ){
                output::errorMismatch(yylineno);
                exit(0);
            }
            
             $$.type ="BOOL";
            

		  }| Exp RELOPR Exp
		  {
			  if((($1.type != "INT") &&($1.type != "BYTE"))  || (($3.type != "INT") &&($3.type != "BYTE"))  ){
                output::errorMismatch(yylineno);
                exit(0);
            }
            
                $$.type ="BOOL";
		  }
		  
%%

int main()
{
	yyparse();
}
		  
/*int yyerror(const char * message)
{

	output::errorSyn(yylineno);
	exit(0);
}*/


	  
		  
		  
