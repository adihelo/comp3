%{
//	#define YYERROR_VERBOSE 1 
	#include <iostream>
	#include <stdlib.h>
	#include "hw3_output.hpp"
	#include "types.hpp"
	using namespace std;
	
	extern int yylex();
	extern int yylineno;
	int yyerror(const char * message);
	
%}

%token    VOID 
%token    INT 
%token    BYTE 
%token    B 
%token    BOOL 

%token    TRUE 
%token    FALSE 
%token    RETURN 
%token    WHILE 
%token    BREAK 
%token    CONTINUE  
%token    SC 
%token    COMMA 
%token    ASSIGN
%token    ID 
%token    NUM 
%token    STRING
%token    SET;

%left OR;                // changed
%left AND;
%left RELOPN;
%left RELOPR;            // is RELOP == | != 
%nonassoc     RELOPL;            // is RELOP <= | >= | > | < should be left 
%left     ADDSUB;               // add is +/-       /// splitted BINOP
%left     MULDIV;               // MUL is * or /
%right    NOT;

%left     LPAREN;
%left    RPAREN;
%nonassoc     COMMA;
%left    LBRACE;
%left    RBRACE;
%left    LBRACKET;
%left  RBRACKET;          /// not sure about LBRACKET AND LBRACKET  should be treated as LBRACE/RBARACE or LPAREN/RPAREN

%left    DOTS;
%nonassoc IF;
%right    ELSE;
%%

Program:  Funcs
          {
			  
		  }
		  
Funcs :  
		  {
		      
		  } 	

		  | FuncDecl Funcs 
		  {
		      
		  }
		  
FuncDecl: RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE 
		  {
			
		  }

RetType:  Type
          {
			  
		  }
		  | VOID
		  {
			  
		  }

Formals: 
		  {
		      
		  }
		  | FormalsList
		  {
		      
		  }		

FormalsList:FormalDecl 
		  {
		      
		  }
		  | FormalDecl COMMA FormalsList
		  {
		      
		  }

FormalDecl: Type ID
		  {
		      
		  }
		  
Statements: Statement
		  {
		      
		  }
		  | Statements Statement	
		  {
		      
		  }
Statement: LBRACE Statements RBRACE	
		  {
		      
		  }
		  | Type ID SC	
		  {
		    cout << $1.type << " " << $2.name << endl;
		  }
		  | Type ID ASSIGN Exp SC	
		  {
		      
		  }
		  | ID ASSIGN Exp SC	
		  {
		      
		  }	
		  | Call SC
		  {
		      
		  }
		  | RETURN SC	
		  {
		      
		  }
		  | RETURN Exp SC
		  {
		      
		  }
		  | IF LPAREN Exp RPAREN Statement 	
		  {
		      
		  }
		  | IF LPAREN Exp RPAREN Statement ELSE Statement
		  {
		      
		  }
		  | WHILE LPAREN Exp RPAREN Statement
		  {
		      
		  }
		  | BREAK SC
		  {
		      
		  }	
		  | CONTINUE SC
		  {
		      
		  }
		  
Call:      ID LPAREN Explist RPAREN 
          {
			  
		  }
          | ID LPAREN RPAREN 
		  {
			  
		  }

Explist:    Exp 
          {
	         
		  }
          | Exp COMMA Explist 
		  {
			  
		  }

Type :      INT 
          {
			$$.type = $1.type;
		  }
          |  BYTE 
		  {
			$$.type = $1.type;
		  }
          | BOOL 
		  {
			$$.type = $1.type;
		  }
          | SET LBRACKET NUM DOTS NUM RBRACKET 
		  {
			 
		  }

Exp:        LPAREN Exp RPAREN 
          {
			 
		  }
          | ID 
		  {
			 
		  }
          | Call 
		  {
			  
		  }
          | NUM 
		  {
			  
		  }
          | NUM B 
		  {
			 
		  }
          | STRING 
		  {
			  
		  }
          | TRUE 
		  {
			  
		  }
          | FALSE 
		  {
			  
		  }
          | NOT Exp 
		  {
			  
		  }
          | Exp AND Exp 
		  {
			  
		  }
          | Exp OR Exp 
		  {
			 
		  }
          | Exp ADDSUB Exp 
		  {
			 
		  }
          | Exp MULDIV Exp 
		  {
			  
		  }| Exp RELOPN Exp 
		  {
			  
		  }
          | LPAREN Type RPAREN Exp 
		  {
			 
		  }
		  | Exp RELOPL Exp
		  {
			
		  }| Exp RELOPR Exp
		  {
			  
		  }
		  
%%

int main()
{
	yyparse();
}
		  
int yyerror(const char * message)
{

	output::errorSyn(yylineno);
	exit(0);
}
		  
	  
		  
		  
