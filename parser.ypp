%{
//	#define YYERROR_VERBOSE 1 
	#include <iostream>
	#include <stdlib.h>
	#include "hw3_output.hpp"
	#include "types.hpp"
	#include "symbolsTable.hpp"
	using namespace std;
	
	extern int yylex();
	extern int yylineno;
	//int yyerror(const char * message);

    symbolsTable vars_table;         // The symbols table for variables.
    FuncsTable funcs_table;          // The table for all functions declared.
    vector<string> curr_func_args;   //saves the args of the function currently being declared

	
%}

%token    VOID 
%token    INT 
%token    BYTE 
%token    B 
%token    BOOL 

%token    TRUE 
%token    FALSE 
%token    RETURN 
%token    WHILE 
%token    BREAK 
%token    CONTINUE  
%token    SC 
%token    COMMA 
%token    ASSIGN
%token    ID 
%token    NUM 
%token    STRING
%token    SET;

%left OR;                // changed
%left AND;
%left RELOPN;
%left RELOPR;            // is RELOP == | != 
%nonassoc     RELOPL;            // is RELOP <= | >= | > | < should be left 
%left     ADDSUB;               // add is +/-       /// splitted BINOP
%left     MULDIV;               // MUL is * or /
%right    NOT;

%left     LPAREN;
%left    RPAREN;
%nonassoc     COMMA;
%left    LBRACE;
%left    RBRACE;
%left    LBRACKET;
%left  RBRACKET;          /// not sure about LBRACKET AND LBRACKET  should be treated as LBRACE/RBARACE or LPAREN/RPAREN

%left    DOTS;
%nonassoc IF;
%right    ELSE;
%%

Program:  Funcs
          {
			  funcs_table.printTable();
		  }
		  
Funcs :  
		  {
		      
		  } 	

		  | FuncDecl Funcs 
		  {
		      
		  }
		  
FuncDecl: RetType ID LPAREN Formals RPAREN { funcs_table.Insert($2.name, $1.type, $4); } LBRACE Statements RBRACE
		  {

		  }

RetType:  Type
          {
			  $$.type = $1.type;
		  }
		  | VOID
		  {
			  $$.type = "VOID";
		  }

Formals: 
		  {
		      $$ = curr_func_args;
		  }
		  | FormalsList
		  {
		      $$ = curr_func_args;
		  }		

FormalsList:FormalDecl 
		  {
		      
		  }
		  | FormalDecl COMMA FormalsList
		  {
		      
		  }

FormalDecl: Type ID
		  {
		      vars_table.Insert($2.name, $1.type,true);
		      curr_func_args.push_back($1.type);
		  }
		  
Statements: Statement
		  {
		      
		  }
		  | Statements Statement	
		  {
		      
		  }
Statement: LBRACE {vars_table.openScope()} Statements {vars_table.closeScope()} RBRACE
		  {
		      
		  }
		  | Type ID SC	
		  {
		       if(vars_table.checkVariableDeclared($2.name) != ""){
		           output::errorDef(yylineno, $2.name);
		           exit(0);
		       }
		       vars_table.Insert($2.name, $1.type);
		  }
		  | Type ID ASSIGN Exp SC	
		  {
		       if(vars_table.checkVariableDeclared($2.name) != ""){
               	   output::errorDef(yylineno, $2.name);
               	   exit(0);
               }
               if($1.type != $4.type){
                   output::errorMismatch(yylineno);
                   exit(0);
               }
               vars_table.Insert($2.name, $1.type);
		      
		  }
		  | ID ASSIGN Exp SC	
		  {
		       if(vars_table.checkVariableDeclared($1.name) == ""){
                    output::errorUndef(yylineno, $1.name);
                    exit(0);
               }
               if(vars_table.checkVariableDeclared($1.name) != $3.type){
                    output::errorMismatch(yylineno);
                    exit(0);
               }
		  }	
		  | Call SC
		  {
		      
		  }
		  | RETURN SC	
		  {
		      if(funcs_table.lastFuncType() != "VOID"){
		          output::errorMismatch(yylineno);
		          exit(0);
		      }
		  }
		  | RETURN Exp SC
		  {
		      if(funcs_table.lastFuncType() != $2.type){
              	  output::errorMismatch(yylineno);
              	  exit(0);
              }
		      
		  }
		  | IF LPAREN Exp RPAREN {
		     if($3.type == "BOOL"){
		         vars_table.openScope();
		     }else{
		         output::errorMismatch(yylineno);
                 exit(0);
		     }

		  } Statement
		  {
		      vars_table.closeScope();
		  }
		  | IF LPAREN Exp RPAREN {
		     if($3.type == "BOOL"){
                 vars_table.openScope();
             }else{
                 output::errorMismatch(yylineno);
                 exit(0);
             }
		   } Statement {vars_table.closeScope();} ELSE {vars_table.openScope();} Statement
		  {
		      vars_table.closeScope();
		  }
		  | WHILE LPAREN Exp RPAREN {vars_table.openScope(); while_mode = true; } Statement
		  {
		      vars_table.closeScope();
		      while_mode = false;
		  }
		  | BREAK SC
		  {
		      if(!while_mode){
		          output::errorUnexpectedBreak(yylineno);
		          exit(0);
		      }
		      
		  }	
		  | CONTINUE SC
		  {
		      if(!while_mode){
		          output::errorUnexpectedContinue(yylineno);
		          exit(0);
		      }
		      
		  }
		  
Call:      ID LPAREN Explist RPAREN 
          {
			  $$=new Call(funcs_table.checkArgsValid(($1->name,dynamic_cast<ExpList*>$3->types)); //not sure about the $1->name
		  }
          | ID LPAREN RPAREN 
		  {
			 $$=new Call(funcs_table.checkArgsValid(($1->name,{}));
		  }

Explist:    Exp 
          {
	         $$= new ExpList (dynamic_cast<Exp*> ($1));
		  }
          | Exp COMMA Explist 
		  {
			$$= new ExpList (dynamic_cast<Exp*>($1),dynamic_cast<ExpList*>($3));  
		  }

Type :      INT 
          {
			$$= new Type($1.type);
		  }
          |  BYTE 
		  {
			$$= new Type($1.type);
		  }
          | BOOL 
		  {
            $$= new Type($1.type);
		  }
          | SET LBRACKET NUM DOTS NUM RBRACKET 
		  {
			 //todo
             if(($2->name >$3->name) || ($3->name - $2->name > 255)){
                output::errorSetTooLarge(yylineno,$1->name, $2->name);  //I am confused with name in Node, shouldn't we save a value and a type.
                exit(0);
             }
             if($2->name >$3->name){
                output::errorSetTooLarge(yylineno,$1->name, $2->name);  //I am confused with name in Node, shouldn't we save a value and a type.
                exit(0);
             }
             $$= new Type("SET");  // set the type to "SET";
		  }

Exp:        LPAREN Exp RPAREN 
          {
			 $$=$1;
		  }
          | ID //todo // I think this needs the function that looks up a variable
		  {
			 string type = vars_table.checkVariableDeclared((dynamic_cast<Exp*>$1->name));
             if(type == ""){
                output::errorUndef(yylineno, (dynamic_cast<Exp*>$1->name));
             }
             $$= new Exp(type);  
		  }
          | Call 
		  {
			  $$=$1; 
		  }
          | NUM 
		  {
            $$= new Exp((char*) "INT");  
			  //$$.type = "INT";
              
		  }
          | NUM B 
		  {
			 
             $$= new Exp((char*) "BYTE");
             if($1.name > 255 ){  //the stored value is name right?   //byte can't be above 255
                output::errorByteTooLarge(yylineno, $1.name);
                exit(0);
             }
		  }
          | STRING 
		  {
			 
              $$= new Exp((char*) "STRING");
		  }
          | TRUE 
		  {
              $$= new Exp((char*) "BOOL");
		  }
          | FALSE 
		  {
              $$= new Exp((char*) "BOOL");
		  }
          | NOT Exp 
		  {
            if($1.type != "BOOL"){
                output::errorMismatch(yylineno);
                exit(0);
            }else{
                $$= new Exp((char*) "BOOL");
            
            }
			  
		  }
          | Exp AND Exp 
		  {
			if(($1.type != "BOOL") || ($3.type != "BOOL")){
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$= new Exp((char*) "BOOL");
		  }
          | Exp OR Exp 
		  {
			 if(($1.type != "BOOL") || ($3.type != "BOOL")){
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$= new Exp((char*) "BOOL");
		  }
          | Exp ADDSUB Exp 
		  {
			 if((($1.type != "INT") &&($1.type != "BYTE"))  || (($3.type != "INT") &&($3.type != "BYTE")) ){
                output::errorMismatch(yylineno);
                exit(0);
            }
            if(($1.type == "INT") ||($2.type == "INT")){
                
                $$= new Exp((char*) "INT");
            }else{
                $$= new Exp((char*) "BOOL");
            
            }
		  }
          | Exp MULDIV Exp 
		  {
			  if((($1.type != "INT") &&($1.type != "BYTE"))  || (($3.type != "INT") &&($3.type != "BYTE"))){
                output::errorMismatch(yylineno);
                exit(0);
            }
            if(($1.type == "INT") ||($2.type == "INT")){
                
                $$= new Exp((char*) "INT");
            }else{
                $$= new Exp((char*) "BYTE");
            
            }
		  }
		  | Exp RELOPN Exp  //todo
		  {
			  if(!((($2.type=="INT")|| ($2.type =="BYTE")) && ($3.type == "SET"))){
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$= new Exp((char*) "BOOL");
		  }
          | LPAREN Type RPAREN Exp 
		  {
            if(($2.type!="INT") || $3.type !="SET"){
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$= new Exp((char*) "INT");
			 
		  }
		  | Exp RELOPL Exp
		  {
			if((($1.type != "INT") &&($1.type != "BYTE"))  || (($3.type != "INT") &&($3.type != "BYTE"))  ){
                output::errorMismatch(yylineno);
                exit(0);
            }
            
             $$= new Exp((char*) "BOOL");
            

		  }| Exp RELOPR Exp
		  {
			  if((($1.type != "INT") &&($1.type != "BYTE"))  || (($3.type != "INT") &&($3.type != "BYTE"))  ){
                output::errorMismatch(yylineno);
                exit(0);
            }
            
                $$= new Exp((char*) "BOOL");
		  }
		  
%%

int main(){
	yyparse();
}
		  
/*int yyerror(const char * message)
{

	output::errorSyn(yylineno);
	exit(0);
}*/